---
title: Persistent Memory Example
description: Complete example showing how to build an AI agent with persistent memory using Room and Shot
---

# Persistent Memory Example

This example demonstrates how to create an AI agent with persistent memory using downcity's Room and Shot components. You'll learn how to maintain conversation context across sessions and build agents that remember previous interactions.

## Overview

We'll build a memory-enabled agent that can:
- Remember conversations across sessions
- Maintain user preferences and context
- Store and retrieve conversation history
- Handle multiple conversation threads
- Demonstrate the three-tier memory system

## Prerequisites

- Completed the [Basic Agent Example](/docs/examples/basic-agent)
- Understanding of [Memory System](/docs/core-concepts/memory-system)
- Node.js 18+ and downcity installed

## Complete Example

```typescript
import { Hero, Room, Shot } from 'downcity';

class PersistentMemoryAgent {
  private hero: Hero;
  private room: Room;
  private currentShot: Shot | null = null;
  private userId: string;
  
  constructor(userId: string) {
    this.userId = userId;
    
    // Initialize Hero
    this.hero = new Hero({
      model: 'gpt-3.5-turbo',
      temperature: 0.7,
      systemPrompt: `You are a helpful AI assistant with memory. 
      You can remember previous conversations and user preferences. 
      Use this memory to provide personalized and contextual responses.`
    });
    
    // Initialize Room for persistent memory
    this.room = Room.create({
      name: `user_${userId}_memory`,
      description: `Persistent memory for user ${userId}`
    });
  }
  
  async startNewConversation(topic?: string): Promise<void> {
    // Create new Shot for this conversation session
    this.currentShot = this.room.createShot();
    
    // Set conversation metadata
    this.currentShot.setMetadata({
      userId: this.userId,
      topic: topic || 'general',
      startTime: new Date().toISOString(),
      messageCount: 0
    });
    
    console.log(`üß† Started new conversation${topic ? ` about ${topic}` : ''}`);
    console.log(`üìù Session ID: ${this.currentShot.getId()}`);
  }
  
  async loadPreviousConversation(shotId: string): Promise<boolean> {
    try {
      this.currentShot = this.room.getShot(shotId);
      if (this.currentShot) {
        console.log(`üîÑ Loaded previous conversation: ${shotId}`);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error loading conversation:', error);
      return false;
    }
  }
  
  async chat(userMessage: string): Promise<string> {
    if (!this.currentShot) {
      await this.startNewConversation();
    }
    
    // Add user message to current shot
    this.currentShot!.addMessage({
      role: 'user',
      content: userMessage,
      timestamp: new Date().toISOString()
    });
    
    // Get conversation context from current shot
    const conversationHistory = this.currentShot!.getMessages()
      .slice(-10) // Last 10 messages for context
      .map(msg => `${msg.role}: ${msg.content}`)
      .join('\\n');\n    
    // Get relevant memories from room
    const relevantMemories = await this.getRelevantMemories(userMessage);
    
    // Build enhanced prompt with memory context
    let enhancedPrompt = userMessage;
    
    if (relevantMemories.length > 0) {
      const memoryContext = relevantMemories
        .map(memory => `Previous context: ${memory}`)
        .join('\\n');\n      enhancedPrompt = `${memoryContext}\\n\\nCurrent conversation:\\n${conversationHistory}\\n\\nUser: ${userMessage}`;\n    } else {\n      enhancedPrompt = `Conversation history:\\n${conversationHistory}\\n\\nUser: ${userMessage}`;\n    }\n    \n    try {\n      // Get response from Hero\n      const response = await this.hero.query(enhancedPrompt);\n      \n      // Add assistant response to current shot\n      this.currentShot!.addMessage({\n        role: 'assistant',\n        content: response,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Update shot metadata\n      const metadata = this.currentShot!.getMetadata();\n      this.currentShot!.updateMetadata({\n        messageCount: (metadata.messageCount || 0) + 2, // user + assistant\n        lastActivity: new Date().toISOString()\n      });\n      \n      // Save important information to room memory\n      await this.saveImportantMemories(userMessage, response);\n      \n      return response;\n    } catch (error) {\n      console.error('Error in chat:', error);\n      return \"I'm sorry, I encountered an error. Please try again.\";\n    }\n  }\n  \n  private async getRelevantMemories(query: string): Promise<string[]> {\n    // Get all shots from room\n    const allShots = this.room.getAllShots();\n    const relevantMemories: string[] = [];\n    \n    // Simple keyword matching for relevant memories\n    const queryWords = query.toLowerCase().split(' ');\n    \n    allShots.forEach(shot => {\n      const messages = shot.getMessages();\n      messages.forEach(message => {\n        const messageWords = message.content.toLowerCase().split(' ');\n        const relevance = queryWords.filter(word => \n          messageWords.some(msgWord => msgWord.includes(word))\n        ).length;\n        \n        if (relevance > 0 && message.role === 'assistant') {\n          relevantMemories.push(message.content);\n        }\n      });\n    });\n    \n    return relevantMemories.slice(0, 3); // Top 3 relevant memories\n  }\n  \n  private async saveImportantMemories(userMessage: string, assistantResponse: string): Promise<void> {\n    // Identify important information to save\n    const importantKeywords = [\n      'my name is', 'i am', 'i like', 'i prefer', 'remember', \n      'important', 'favorite', 'birthday', 'anniversary'\n    ];\n    \n    const userLower = userMessage.toLowerCase();\n    const isImportant = importantKeywords.some(keyword => userLower.includes(keyword));\n    \n    if (isImportant) {\n      // Create a memory entry in room\n      const memoryShot = this.room.createShot();\n      memoryShot.setMetadata({\n        type: 'important_memory',\n        userId: this.userId,\n        extractedFrom: this.currentShot!.getId(),\n        timestamp: new Date().toISOString()\n      });\n      \n      memoryShot.addMessage({\n        role: 'system',\n        content: `Important user information: ${userMessage}`,\n        timestamp: new Date().toISOString()\n      });\n      \n      memoryShot.addMessage({\n        role: 'system',\n        content: `Context: ${assistantResponse}`,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n  \n  async getConversationSummary(): Promise<string> {\n    if (!this.currentShot) {\n      return \"No active conversation.\";\n    }\n    \n    const messages = this.currentShot.getMessages();\n    const metadata = this.currentShot.getMetadata();\n    \n    return `\nüìä Conversation Summary:\n- Session ID: ${this.currentShot.getId()}\n- Topic: ${metadata.topic || 'General'}\n- Messages: ${messages.length}\n- Started: ${new Date(metadata.startTime).toLocaleString()}\n- Last Activity: ${metadata.lastActivity ? new Date(metadata.lastActivity).toLocaleString() : 'N/A'}\n    `.trim();\n  }\n  \n  async listPreviousConversations(): Promise<Array<{id: string, topic: string, messageCount: number, startTime: string}>> {\n    const allShots = this.room.getAllShots();\n    \n    return allShots\n      .filter(shot => {\n        const metadata = shot.getMetadata();\n        return metadata.userId === this.userId && metadata.type !== 'important_memory';\n      })\n      .map(shot => {\n        const metadata = shot.getMetadata();\n        return {\n          id: shot.getId(),\n          topic: metadata.topic || 'General',\n          messageCount: shot.getMessages().length,\n          startTime: metadata.startTime || shot.getCreatedAt().toISOString()\n        };\n      })\n      .sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());\n  }\n  \n  async exportConversation(shotId?: string): Promise<string> {\n    const shot = shotId ? this.room.getShot(shotId) : this.currentShot;\n    \n    if (!shot) {\n      return \"No conversation to export.\";\n    }\n    \n    const messages = shot.getMessages();\n    const metadata = shot.getMetadata();\n    \n    let export_text = `# Conversation Export\\n\\n`;\n    export_text += `**Session ID:** ${shot.getId()}\\n`;\n    export_text += `**Topic:** ${metadata.topic || 'General'}\\n`;\n    export_text += `**Started:** ${new Date(metadata.startTime).toLocaleString()}\\n`;\n    export_text += `**Messages:** ${messages.length}\\n\\n`;\n    export_text += `---\\n\\n`;\n    \n    messages.forEach((message, index) => {\n      const timestamp = new Date(message.timestamp).toLocaleTimeString();\n      export_text += `**${message.role.toUpperCase()}** (${timestamp}):\\n${message.content}\\n\\n`;\n    });\n    \n    return export_text;\n  }\n  \n  close(): void {\n    this.room.close();\n  }\n}\n\n// Interactive CLI for the memory agent\nclass MemoryAgentCLI {\n  private agent: PersistentMemoryAgent;\n  private readline: any;\n  \n  constructor(userId: string) {\n    this.agent = new PersistentMemoryAgent(userId);\n    this.readline = require('readline').createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n  }\n  \n  async start(): Promise<void> {\n    console.log('üß† Persistent Memory Agent Started!');\n    console.log('Commands: /new [topic], /load <id>, /list, /summary, /export, /help, /quit\\n');\n    \n    await this.agent.startNewConversation();\n    this.askQuestion();\n  }\n  \n  private askQuestion(): void {\n    this.readline.question('You: ', async (input: string) => {\n      const trimmed = input.trim();\n      \n      if (trimmed.startsWith('/')) {\n        await this.handleCommand(trimmed);\n      } else if (trimmed.toLowerCase() === 'quit') {\n        console.log('üëã Goodbye!');\n        this.agent.close();\n        this.readline.close();\n        return;\n      } else {\n        console.log('ü§ñ Thinking...');\n        const response = await this.agent.chat(trimmed);\n        console.log(`Agent: ${response}\\n`);\n      }\n      \n      this.askQuestion();\n    });\n  }\n  \n  private async handleCommand(command: string): Promise<void> {\n    const parts = command.split(' ');\n    const cmd = parts[0];\n    \n    switch (cmd) {\n      case '/new':\n        const topic = parts.slice(1).join(' ');\n        await this.agent.startNewConversation(topic || undefined);\n        break;\n        \n      case '/load':\n        if (parts[1]) {\n          const loaded = await this.agent.loadPreviousConversation(parts[1]);\n          if (!loaded) {\n            console.log('‚ùå Could not load conversation with that ID');\n          }\n        } else {\n          console.log('‚ùå Please provide a conversation ID');\n        }\n        break;\n        \n      case '/list':\n        const conversations = await this.agent.listPreviousConversations();\n        console.log('\\nüìö Previous Conversations:');\n        conversations.forEach((conv, index) => {\n          console.log(`${index + 1}. ${conv.topic} (${conv.messageCount} messages) - ${conv.id}`);\n          console.log(`   Started: ${new Date(conv.startTime).toLocaleString()}`);\n        });\n        console.log('');\n        break;\n        \n      case '/summary':\n        const summary = await this.agent.getConversationSummary();\n        console.log(summary + '\\n');\n        break;\n        \n      case '/export':\n        const exportText = await this.agent.exportConversation(parts[1]);\n        console.log('\\n' + exportText);\n        break;\n        \n      case '/help':\n        console.log(`\nüîß Available Commands:\n- /new [topic] - Start new conversation\n- /load <id> - Load previous conversation\n- /list - List all conversations\n- /summary - Show current conversation summary\n- /export [id] - Export conversation to text\n- /help - Show this help\n- /quit - Exit the agent\n`);\n        break;\n        \n      default:\n        console.log('‚ùå Unknown command. Type /help for available commands.');\n    }\n  }\n}\n\n// Usage\nasync function main() {\n  const userId = process.argv[2] || 'default_user';\n  const cli = new MemoryAgentCLI(userId);\n  await cli.start();\n}\n\n// Run the agent\nif (require.main === module) {\n  main().catch(console.error);\n}\n```\n\n## Step-by-Step Breakdown\n\n### Step 1: Initialize Memory Components\n\n```typescript\nclass PersistentMemoryAgent {\n  private hero: Hero;\n  private room: Room;\n  private currentShot: Shot | null = null;\n  private userId: string;\n  \n  constructor(userId: string) {\n    this.userId = userId;\n    \n    // Hero for AI responses\n    this.hero = new Hero({\n      model: 'gpt-3.5-turbo',\n      temperature: 0.7,\n      systemPrompt: `You are a helpful AI assistant with memory...`\n    });\n    \n    // Room for persistent memory storage\n    this.room = Room.create({\n      name: `user_${userId}_memory`,\n      description: `Persistent memory for user ${userId}`\n    });\n  }\n}\n```\n\n**Key Points:**\n- Room provides persistent storage across sessions\n- Each user gets their own Room instance\n- Shot will be created for each conversation session\n- Hero handles the AI responses with memory context\n\n### Step 2: Conversation Session Management\n\n```typescript\nasync startNewConversation(topic?: string): Promise<void> {\n  // Create new Shot for this conversation session\n  this.currentShot = this.room.createShot();\n  \n  // Set conversation metadata\n  this.currentShot.setMetadata({\n    userId: this.userId,\n    topic: topic || 'general',\n    startTime: new Date().toISOString(),\n    messageCount: 0\n  });\n}\n\nasync loadPreviousConversation(shotId: string): Promise<boolean> {\n  try {\n    this.currentShot = this.room.getShot(shotId);\n    return this.currentShot !== null;\n  } catch (error) {\n    console.error('Error loading conversation:', error);\n    return false;\n  }\n}\n```\n\n**Key Points:**\n- Each conversation session is a separate Shot\n- Shots are created within the Room for persistence\n- Metadata tracks conversation details\n- Previous conversations can be loaded by ID\n\n### Step 3: Memory-Enhanced Chat\n\n```typescript\nasync chat(userMessage: string): Promise<string> {\n  // Add user message to current shot\n  this.currentShot!.addMessage({\n    role: 'user',\n    content: userMessage,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Get conversation context\n  const conversationHistory = this.currentShot!.getMessages()\n    .slice(-10) // Last 10 messages\n    .map(msg => `${msg.role}: ${msg.content}`)\n    .join('\\n');\n  \n  // Get relevant memories from room\n  const relevantMemories = await this.getRelevantMemories(userMessage);\n  \n  // Build enhanced prompt with memory context\n  let enhancedPrompt = userMessage;\n  if (relevantMemories.length > 0) {\n    const memoryContext = relevantMemories\n      .map(memory => `Previous context: ${memory}`)\n      .join('\\n');\n    enhancedPrompt = `${memoryContext}\\n\\nCurrent conversation:\\n${conversationHistory}\\n\\nUser: ${userMessage}`;\n  }\n  \n  const response = await this.hero.query(enhancedPrompt);\n  \n  // Add response to shot\n  this.currentShot!.addMessage({\n    role: 'assistant',\n    content: response,\n    timestamp: new Date().toISOString()\n  });\n  \n  return response;\n}\n```\n\n**Key Points:**\n- Messages are stored in the current Shot\n- Conversation history provides immediate context\n- Relevant memories from previous conversations enhance responses\n- Both user and assistant messages are persisted\n\n### Step 4: Memory Retrieval and Storage\n\n```typescript\nprivate async getRelevantMemories(query: string): Promise<string[]> {\n  const allShots = this.room.getAllShots();\n  const relevantMemories: string[] = [];\n  \n  // Simple keyword matching for relevant memories\n  const queryWords = query.toLowerCase().split(' ');\n  \n  allShots.forEach(shot => {\n    const messages = shot.getMessages();\n    messages.forEach(message => {\n      const messageWords = message.content.toLowerCase().split(' ');\n      const relevance = queryWords.filter(word => \n        messageWords.some(msgWord => msgWord.includes(word))\n      ).length;\n      \n      if (relevance > 0 && message.role === 'assistant') {\n        relevantMemories.push(message.content);\n      }\n    });\n  });\n  \n  return relevantMemories.slice(0, 3); // Top 3 relevant memories\n}\n\nprivate async saveImportantMemories(userMessage: string, assistantResponse: string): Promise<void> {\n  const importantKeywords = [\n    'my name is', 'i am', 'i like', 'i prefer', 'remember', \n    'important', 'favorite', 'birthday', 'anniversary'\n  ];\n  \n  const userLower = userMessage.toLowerCase();\n  const isImportant = importantKeywords.some(keyword => userLower.includes(keyword));\n  \n  if (isImportant) {\n    // Create a memory entry in room\n    const memoryShot = this.room.createShot();\n    memoryShot.setMetadata({\n      type: 'important_memory',\n      userId: this.userId,\n      extractedFrom: this.currentShot!.getId(),\n      timestamp: new Date().toISOString()\n    });\n    \n    memoryShot.addMessage({\n      role: 'system',\n      content: `Important user information: ${userMessage}`,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n```\n\n**Key Points:**\n- Memory retrieval uses keyword matching across all shots\n- Important information is automatically detected and stored\n- Special memory shots store key user information\n- Memory system scales with conversation history\n\n## Running the Example\n\n### 1. Save and Setup\n\n```bash\n# Create project\nmkdir persistent-memory-agent\ncd persistent-memory-agent\n\n# Initialize and install dependencies\nnpm init -y\nnpm install downcity\nnpm install -D typescript @types/node\n\n# Create the agent file\ntouch persistent-agent.ts\n```\n\n### 2. Run the Agent\n\n```bash\n# Run with default user\nnpx ts-node persistent-agent.ts\n\n# Run with specific user ID\nnpx ts-node persistent-agent.ts john_doe\n```\n\n### 3. Example Interaction\n\n```\nüß† Persistent Memory Agent Started!\nCommands: /new [topic], /load <id>, /list, /summary, /export, /help, /quit\n\nüß† Started new conversation\nüìù Session ID: shot_1234567890_abc123\n\nYou: Hi, my name is John and I love programming\nü§ñ Thinking...\nAgent: Hello John! It's great to meet you. I can see you love programming - that's fantastic! I'll remember that about you. What kind of programming do you enjoy most?\n\nYou: I'm particularly interested in TypeScript and React\nü§ñ Thinking...\nAgent: Excellent choice, John! TypeScript and React make a powerful combination. TypeScript's type safety really helps with React development. Are you working on any specific projects with these technologies?\n\nYou: /new web development\nüß† Started new conversation about web development\nüìù Session ID: shot_1234567890_def456\n\nYou: What's the best way to handle state in React?\nü§ñ Thinking...\nAgent: Hi John! Since you mentioned you love programming and are interested in TypeScript and React, I can give you some targeted advice on React state management...\n\nYou: /list\n\nüìö Previous Conversations:\n1. web development (4 messages) - shot_1234567890_def456\n   Started: 12/1/2023, 2:30:15 PM\n2. general (4 messages) - shot_1234567890_abc123\n   Started: 12/1/2023, 2:25:10 PM\n\nYou: /load shot_1234567890_abc123\nüîÑ Loaded previous conversation: shot_1234567890_abc123\n\nYou: Do you remember what I told you about myself?\nü§ñ Thinking...\nAgent: Yes, John! I remember you told me your name is John and that you love programming. You're particularly interested in TypeScript and React. It's great to continue our conversation!\n```\n\n## Advanced Features\n\n### Memory Analytics\n\n```typescript\nclass MemoryAnalytics {\n  constructor(private room: Room) {}\n  \n  getMemoryStats(): {\n    totalConversations: number;\n    totalMessages: number;\n    averageMessagesPerConversation: number;\n    memoryEntries: number;\n    oldestConversation: Date;\n    newestConversation: Date;\n  } {\n    const allShots = this.room.getAllShots();\n    const conversationShots = allShots.filter(shot => \n      shot.getMetadata().type !== 'important_memory'\n    );\n    const memoryShots = allShots.filter(shot => \n      shot.getMetadata().type === 'important_memory'\n    );\n    \n    const totalMessages = conversationShots.reduce((sum, shot) => \n      sum + shot.getMessages().length, 0\n    );\n    \n    const dates = conversationShots.map(shot => shot.getCreatedAt());\n    \n    return {\n      totalConversations: conversationShots.length,\n      totalMessages,\n      averageMessagesPerConversation: totalMessages / conversationShots.length || 0,\n      memoryEntries: memoryShots.length,\n      oldestConversation: new Date(Math.min(...dates.map(d => d.getTime()))),\n      newestConversation: new Date(Math.max(...dates.map(d => d.getTime())))\n    };\n  }\n  \n  findConversationsByTopic(topic: string): Shot[] {\n    return this.room.getAllShots().filter(shot => {\n      const metadata = shot.getMetadata();\n      return metadata.topic && metadata.topic.toLowerCase().includes(topic.toLowerCase());\n    });\n  }\n  \n  getConversationTrends(): Record<string, number> {\n    const topics: Record<string, number> = {};\n    \n    this.room.getAllShots().forEach(shot => {\n      const topic = shot.getMetadata().topic || 'general';\n      topics[topic] = (topics[topic] || 0) + 1;\n    });\n    \n    return topics;\n  }\n}\n```\n\n### Memory Cleanup\n\n```typescript\nclass MemoryManager {\n  constructor(private room: Room) {}\n  \n  async cleanupOldConversations(daysOld: number = 30): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n    \n    const allShots = this.room.getAllShots();\n    let deletedCount = 0;\n    \n    allShots.forEach(shot => {\n      if (shot.getCreatedAt() < cutoffDate) {\n        this.room.deleteShot(shot.getId());\n        deletedCount++;\n      }\n    });\n    \n    return deletedCount;\n  }\n  \n  async archiveConversation(shotId: string): Promise<boolean> {\n    const shot = this.room.getShot(shotId);\n    if (!shot) return false;\n    \n    // Update metadata to mark as archived\n    shot.updateMetadata({\n      archived: true,\n      archivedAt: new Date().toISOString()\n    });\n    \n    return true;\n  }\n  \n  getActiveConversations(): Shot[] {\n    return this.room.getAllShots().filter(shot => {\n      const metadata = shot.getMetadata();\n      return !metadata.archived && metadata.type !== 'important_memory';\n    });\n  }\n}\n```\n\n### Enhanced Memory Search\n\n```typescript\nclass SmartMemoryRetrieval {\n  constructor(private room: Room) {}\n  \n  async findRelevantMemories(query: string, limit: number = 5): Promise<{\n    content: string;\n    relevance: number;\n    source: string;\n    timestamp: string;\n  }[]> {\n    const allShots = this.room.getAllShots();\n    const memories: Array<{\n      content: string;\n      relevance: number;\n      source: string;\n      timestamp: string;\n    }> = [];\n    \n    const queryWords = query.toLowerCase().split(' ');\n    \n    allShots.forEach(shot => {\n      const messages = shot.getMessages();\n      messages.forEach(message => {\n        if (message.role === 'assistant') {\n          const contentWords = message.content.toLowerCase().split(' ');\n          \n          // Calculate relevance score\n          let relevance = 0;\n          queryWords.forEach(queryWord => {\n            contentWords.forEach(contentWord => {\n              if (contentWord.includes(queryWord) || queryWord.includes(contentWord)) {\n                relevance += queryWord.length > 3 ? 2 : 1; // Longer words get higher weight\n              }\n            });\n          });\n          \n          if (relevance > 0) {\n            memories.push({\n              content: message.content,\n              relevance,\n              source: shot.getId(),\n              timestamp: message.timestamp\n            });\n          }\n        }\n      });\n    });\n    \n    return memories\n      .sort((a, b) => b.relevance - a.relevance)\n      .slice(0, limit);\n  }\n  \n  async getConversationContext(shotId: string, messageIndex: number, contextSize: number = 3): Promise<{\n    before: any[];\n    current: any;\n    after: any[];\n  }> {\n    const shot = this.room.getShot(shotId);\n    if (!shot) throw new Error('Shot not found');\n    \n    const messages = shot.getMessages();\n    const current = messages[messageIndex];\n    \n    return {\n      before: messages.slice(Math.max(0, messageIndex - contextSize), messageIndex),\n      current,\n      after: messages.slice(messageIndex + 1, messageIndex + 1 + contextSize)\n    };\n  }\n}\n```\n\n## Testing Memory Persistence\n\n### Unit Tests\n\n```typescript\n// persistent-agent.test.ts\nimport { PersistentMemoryAgent } from './persistent-agent';\n\ndescribe('PersistentMemoryAgent', () => {\n  let agent: PersistentMemoryAgent;\n  \n  beforeEach(() => {\n    agent = new PersistentMemoryAgent('test_user');\n  });\n  \n  afterEach(() => {\n    agent.close();\n  });\n  \n  test('should remember information across conversations', async () => {\n    // Start first conversation\n    await agent.startNewConversation('introduction');\n    await agent.chat('My name is Alice and I love cats');\n    \n    // Start new conversation\n    await agent.startNewConversation('pets');\n    const response = await agent.chat('What do you know about me?');\n    \n    expect(response.toLowerCase()).toContain('alice');\n    expect(response.toLowerCase()).toContain('cats');\n  });\n  \n  test('should maintain conversation history within session', async () => {\n    await agent.startNewConversation();\n    await agent.chat('I am learning TypeScript');\n    const response = await agent.chat('What was I just talking about?');\n    \n    expect(response.toLowerCase()).toContain('typescript');\n  });\n  \n  test('should list previous conversations', async () => {\n    await agent.startNewConversation('topic1');\n    await agent.chat('Hello');\n    \n    await agent.startNewConversation('topic2');\n    await agent.chat('Hi there');\n    \n    const conversations = await agent.listPreviousConversations();\n    expect(conversations).toHaveLength(2);\n    expect(conversations[0].topic).toBe('topic2'); // Most recent first\n    expect(conversations[1].topic).toBe('topic1');\n  });\n});\n```\n\n### Integration Tests\n\n```typescript\ndescribe('Memory Integration', () => {\n  test('should persist memory across agent instances', async () => {\n    const userId = 'integration_test_user';\n    \n    // First agent instance\n    const agent1 = new PersistentMemoryAgent(userId);\n    await agent1.startNewConversation();\n    await agent1.chat('Remember that I work at TechCorp');\n    agent1.close();\n    \n    // Second agent instance (simulating restart)\n    const agent2 = new PersistentMemoryAgent(userId);\n    await agent2.startNewConversation();\n    const response = await agent2.chat('Where do I work?');\n    \n    expect(response.toLowerCase()).toContain('techcorp');\n    agent2.close();\n  });\n});\n```\n\n## Best Practices\n\n### Memory Management\n\n1. **Limit Context Size**: Don't load entire conversation history\n2. **Relevance Scoring**: Implement smart memory retrieval\n3. **Memory Cleanup**: Regularly archive or delete old conversations\n4. **Metadata Usage**: Use rich metadata for better organization\n\n### Performance Optimization\n\n1. **Lazy Loading**: Load conversations only when needed\n2. **Caching**: Cache frequently accessed memories\n3. **Indexing**: Use metadata for efficient searching\n4. **Batch Operations**: Group memory operations when possible\n\n### Error Handling\n\n1. **Graceful Degradation**: Continue without memory if storage fails\n2. **Backup Strategies**: Implement memory backup and restore\n3. **Validation**: Validate memory data before use\n4. **Recovery**: Handle corrupted memory gracefully\n\n## Next Steps\n\nAfter mastering persistent memory, explore:\n\n1. **[Knowledge Base Example](/docs/examples/knowledge-base)** - Add external knowledge with Codex\n2. **[Advanced Patterns](/docs/guides/advanced-patterns)** - Complex memory architectures\n3. **[Memory Management Guide](/docs/guides/memory-management)** - Production memory strategies\n\n## Related Documentation\n\n- [Room API Reference](/docs/api-reference/room-api) - Detailed Room methods\n- [Shot API Reference](/docs/api-reference/shot-api) - Shot management\n- [Memory System Concepts](/docs/core-concepts/memory-system) - Understanding the memory hierarchy