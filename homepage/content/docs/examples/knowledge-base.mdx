---
title: Knowledge Base Example
description: Complete example showing how to build an AI agent with external knowledge using Codex integration
---

# Knowledge Base Example

This example demonstrates how to create an AI agent with external knowledge capabilities using downcity's Codex component. You'll learn how to build a Retrieval Augmented Generation (RAG) system that can answer questions based on your own knowledge base.

## Overview

We'll build a knowledge-enhanced agent that can:
- Ingest documents and create a searchable knowledge base
- Retrieve relevant information for user queries
- Provide accurate answers based on stored knowledge
- Combine conversational AI with factual information
- Handle multiple knowledge domains

## Prerequisites

- Completed [Basic Agent](/docs/examples/basic-agent) and [Persistent Memory](/docs/examples/persistent-memory) examples
- Understanding of [Codex concepts](/docs/core-concepts/codex)
- Node.js 18+ and downcity installed

## Complete Example

```typescript
import { Hero, Room, Shot, Codex } from 'downcity';
import * as fs from 'fs';
import * as path from 'path';

class KnowledgeBaseAgent {
  private hero: Hero;
  private room: Room;
  private codex: Codex;
  private currentShot: Shot | null = null;
  private userId: string;
  
  constructor(userId: string, knowledgeBaseName: string = 'default_kb') {
    this.userId = userId;
    
    // Initialize Hero with RAG-optimized prompt
    this.hero = new Hero({
      model: 'gpt-3.5-turbo',
      temperature: 0.3, // Lower temperature for more factual responses
      systemPrompt: `You are a knowledgeable AI assistant with access to a specialized knowledge base. 
      When answering questions:
      1. Use the provided context information when available
      2. Clearly distinguish between information from your knowledge base and general knowledge
      3. If you don't have specific information, say so honestly
      4. Provide accurate, well-sourced responses
      5. Ask clarifying questions when the query is ambiguous`
    });
    
    // Initialize Room for conversation memory
    this.room = Room.create({
      name: `${userId}_kb_conversations`,
      description: `Knowledge base conversations for ${userId}`
    });
    
    // Initialize Codex for knowledge storage
    this.codex = Codex.create({
      tableName: `kb_${knowledgeBaseName}`,
      model: 'text-embedding-ada-002',
      dimensions: 1536
    });
  }
  
  async ingestDocument(filePath: string, metadata?: Record<string, any>): Promise<void> {
    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const fileName = path.basename(filePath);
      const fileExtension = path.extname(filePath);
      
      console.log(`📄 Ingesting document: ${fileName}`);\n      \n      // Split document into chunks for better retrieval\n      const chunks = this.chunkDocument(content, 500);\n      \n      for (let i = 0; i < chunks.length; i++) {\n        const chunkMetadata = {\n          fileName,\n          fileExtension,\n          chunkIndex: i,\n          totalChunks: chunks.length,\n          filePath,\n          ingestedAt: new Date().toISOString(),\n          ...metadata\n        };\n        \n        await this.codex.add(chunks[i], chunkMetadata);\n      }\n      \n      console.log(`✅ Successfully ingested ${chunks.length} chunks from ${fileName}`);\n    } catch (error) {\n      console.error(`❌ Error ingesting document ${filePath}:`, error);\n      throw error;\n    }\n  }\n  \n  async ingestText(content: string, metadata: Record<string, any>): Promise<void> {\n    try {\n      const chunks = this.chunkDocument(content, 500);\n      \n      for (let i = 0; i < chunks.length; i++) {\n        const chunkMetadata = {\n          chunkIndex: i,\n          totalChunks: chunks.length,\n          ingestedAt: new Date().toISOString(),\n          ...metadata\n        };\n        \n        await this.codex.add(chunks[i], chunkMetadata);\n      }\n      \n      console.log(`✅ Successfully ingested ${chunks.length} text chunks`);\n    } catch (error) {\n      console.error('❌ Error ingesting text:', error);\n      throw error;\n    }\n  }\n  \n  private chunkDocument(content: string, maxChunkSize: number): string[] {\n    // Split by paragraphs first\n    const paragraphs = content.split(/\\n\\s*\\n/).filter(p => p.trim().length > 0);\n    const chunks: string[] = [];\n    let currentChunk = '';\n    \n    for (const paragraph of paragraphs) {\n      // If adding this paragraph would exceed chunk size\n      if (currentChunk.length + paragraph.length > maxChunkSize) {\n        // Save current chunk if it has content\n        if (currentChunk.trim()) {\n          chunks.push(currentChunk.trim());\n          currentChunk = '';\n        }\n        \n        // If paragraph itself is too long, split by sentences\n        if (paragraph.length > maxChunkSize) {\n          const sentences = paragraph.split(/[.!?]+/).filter(s => s.trim().length > 0);\n          let sentenceChunk = '';\n          \n          for (const sentence of sentences) {\n            if (sentenceChunk.length + sentence.length > maxChunkSize) {\n              if (sentenceChunk.trim()) {\n                chunks.push(sentenceChunk.trim());\n                sentenceChunk = '';\n              }\n            }\n            sentenceChunk += sentence + '. ';\n          }\n          \n          if (sentenceChunk.trim()) {\n            currentChunk = sentenceChunk;\n          }\n        } else {\n          currentChunk = paragraph;\n        }\n      } else {\n        currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph;\n      }\n    }\n    \n    // Add final chunk\n    if (currentChunk.trim()) {\n      chunks.push(currentChunk.trim());\n    }\n    \n    return chunks;\n  }\n  \n  async startConversation(topic?: string): Promise<void> {\n    this.currentShot = this.room.createShot();\n    \n    this.currentShot.setMetadata({\n      userId: this.userId,\n      topic: topic || 'knowledge_query',\n      startTime: new Date().toISOString(),\n      type: 'knowledge_conversation'\n    });\n    \n    console.log(`🧠 Started knowledge-based conversation${topic ? ` about ${topic}` : ''}`);\n  }\n  \n  async query(userQuestion: string): Promise<{\n    answer: string;\n    sources: Array<{\n      content: string;\n      metadata: Record<string, any>;\n      relevance: number;\n    }>;\n    confidence: 'high' | 'medium' | 'low';\n  }> {\n    if (!this.currentShot) {\n      await this.startConversation();\n    }\n    \n    // Add user question to conversation\n    this.currentShot!.addMessage({\n      role: 'user',\n      content: userQuestion,\n      timestamp: new Date().toISOString()\n    });\n    \n    try {\n      // Search knowledge base for relevant information\n      const knowledgeResults = await this.codex.search(userQuestion, {\n        limit: 5,\n        distanceThreshold: 0.4\n      });\n      \n      console.log(`🔍 Found ${knowledgeResults.length} relevant knowledge chunks`);\n      \n      // Build context from search results\n      const context = knowledgeResults\n        .map((result, index) => `[Source ${index + 1}]: ${result.content}`)\n        .join('\\n\\n');\n      \n      // Get conversation history for additional context\n      const conversationHistory = this.currentShot!.getMessages()\n        .slice(-6) // Last 6 messages\n        .map(msg => `${msg.role}: ${msg.content}`)\n        .join('\\n');\n      \n      // Build enhanced prompt\n      let enhancedPrompt = userQuestion;\n      \n      if (context) {\n        enhancedPrompt = `Context from knowledge base:\n${context}\n\nConversation history:\n${conversationHistory}\n\nUser question: ${userQuestion}\n\nPlease answer the question using the provided context. If the context doesn't contain enough information, say so clearly.`;\n      } else {\n        enhancedPrompt = `Conversation history:\n${conversationHistory}\n\nUser question: ${userQuestion}\n\nI don't have specific information about this topic in my knowledge base. Please provide a general response and suggest how the user might find more specific information.`;\n      }\n      \n      // Get response from Hero\n      const response = await this.hero.query(enhancedPrompt);\n      \n      // Add response to conversation\n      this.currentShot!.addMessage({\n        role: 'assistant',\n        content: response,\n        timestamp: new Date().toISOString(),\n        metadata: {\n          knowledgeSourcesUsed: knowledgeResults.length,\n          searchQuery: userQuestion\n        }\n      });\n      \n      // Determine confidence based on knowledge results\n      let confidence: 'high' | 'medium' | 'low' = 'low';\n      if (knowledgeResults.length > 0) {\n        const avgDistance = knowledgeResults.reduce((sum, r) => sum + r.distance, 0) / knowledgeResults.length;\n        if (avgDistance < 0.2) confidence = 'high';\n        else if (avgDistance < 0.4) confidence = 'medium';\n      }\n      \n      return {\n        answer: response,\n        sources: knowledgeResults.map(result => ({\n          content: result.content,\n          metadata: result.metadata,\n          relevance: 1 - result.distance\n        })),\n        confidence\n      };\n      \n    } catch (error) {\n      console.error('Error in knowledge query:', error);\n      return {\n        answer: \"I'm sorry, I encountered an error while searching my knowledge base. Please try again.\",\n        sources: [],\n        confidence: 'low'\n      };\n    }\n  }\n  \n  async searchKnowledge(query: string, options?: {\n    limit?: number;\n    category?: string;\n    fileType?: string;\n  }): Promise<Array<{\n    content: string;\n    metadata: Record<string, any>;\n    relevance: number;\n  }>> {\n    const searchOptions: any = {\n      limit: options?.limit || 10,\n      distanceThreshold: 0.6\n    };\n    \n    // Add metadata filters if specified\n    if (options?.category || options?.fileType) {\n      searchOptions.metadata = {};\n      if (options.category) searchOptions.metadata.category = options.category;\n      if (options.fileType) searchOptions.metadata.fileExtension = options.fileType;\n    }\n    \n    const results = await this.codex.search(query, searchOptions);\n    \n    return results.map(result => ({\n      content: result.content,\n      metadata: result.metadata,\n      relevance: 1 - result.distance\n    }));\n  }\n  \n  async getKnowledgeStats(): Promise<{\n    totalDocuments: number;\n    categories: Record<string, number>;\n    fileTypes: Record<string, number>;\n    recentIngestions: Array<{\n      fileName: string;\n      ingestedAt: string;\n      chunks: number;\n    }>;\n  }> {\n    // This would require additional Codex methods in a real implementation\n    // For now, we'll simulate the response\n    return {\n      totalDocuments: 0, // Would be calculated from Codex\n      categories: {},\n      fileTypes: {},\n      recentIngestions: []\n    };\n  }\n  \n  async exportConversation(): Promise<string> {\n    if (!this.currentShot) {\n      return \"No active conversation to export.\";\n    }\n    \n    const messages = this.currentShot.getMessages();\n    const metadata = this.currentShot.getMetadata();\n    \n    let exportText = `# Knowledge Base Conversation Export\\n\\n`;\n    exportText += `**Topic:** ${metadata.topic}\\n`;\n    exportText += `**Started:** ${new Date(metadata.startTime).toLocaleString()}\\n`;\n    exportText += `**Messages:** ${messages.length}\\n\\n`;\n    exportText += `---\\n\\n`;\n    \n    messages.forEach((message, index) => {\n      const timestamp = new Date(message.timestamp).toLocaleTimeString();\n      exportText += `**${message.role.toUpperCase()}** (${timestamp}):\\n${message.content}\\n\\n`;\n      \n      if (message.metadata?.knowledgeSourcesUsed) {\n        exportText += `*Used ${message.metadata.knowledgeSourcesUsed} knowledge sources*\\n\\n`;\n      }\n    });\n    \n    return exportText;\n  }\n  \n  close(): void {\n    this.room.close();\n    this.codex.close();\n  }\n}\n\n// CLI Interface for Knowledge Base Agent\nclass KnowledgeBaseCLI {\n  private agent: KnowledgeBaseAgent;\n  private readline: any;\n  \n  constructor(userId: string, knowledgeBaseName?: string) {\n    this.agent = new KnowledgeBaseAgent(userId, knowledgeBaseName);\n    this.readline = require('readline').createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n  }\n  \n  async start(): Promise<void> {\n    console.log('📚 Knowledge Base Agent Started!');\n    console.log('Commands: /ingest <file>, /ingest-text, /search <query>, /stats, /export, /help, /quit\\n');\n    \n    await this.agent.startConversation();\n    this.askQuestion();\n  }\n  \n  private askQuestion(): void {\n    this.readline.question('You: ', async (input: string) => {\n      const trimmed = input.trim();\n      \n      if (trimmed.startsWith('/')) {\n        await this.handleCommand(trimmed);\n      } else if (trimmed.toLowerCase() === 'quit') {\n        console.log('👋 Goodbye!');\n        this.agent.close();\n        this.readline.close();\n        return;\n      } else {\n        console.log('🤖 Searching knowledge base...');\n        const result = await this.agent.query(trimmed);\n        \n        console.log(`\\nAgent: ${result.answer}`);\n        console.log(`\\n📊 Confidence: ${result.confidence.toUpperCase()}`);\n        \n        if (result.sources.length > 0) {\n          console.log(`\\n📚 Sources used (${result.sources.length}):`);\n          result.sources.forEach((source, index) => {\n            console.log(`${index + 1}. ${source.metadata.fileName || 'Text'} (relevance: ${(source.relevance * 100).toFixed(1)}%)`);\n          });\n        }\n        console.log('');\n      }\n      \n      this.askQuestion();\n    });\n  }\n  \n  private async handleCommand(command: string): Promise<void> {\n    const parts = command.split(' ');\n    const cmd = parts[0];\n    \n    switch (cmd) {\n      case '/ingest':\n        if (parts[1]) {\n          try {\n            await this.agent.ingestDocument(parts[1], {\n              category: parts[2] || 'general'\n            });\n          } catch (error) {\n            console.log('❌ Error ingesting document:', error);\n          }\n        } else {\n          console.log('❌ Please provide a file path: /ingest <file> [category]');\n        }\n        break;\n        \n      case '/ingest-text':\n        console.log('Enter text to ingest (end with \"END\" on a new line):');\n        this.collectText((text) => {\n          const category = parts[1] || 'general';\n          this.agent.ingestText(text, { category, source: 'manual_input' });\n        });\n        break;\n        \n      case '/search':\n        if (parts.length > 1) {\n          const query = parts.slice(1).join(' ');\n          const results = await this.agent.searchKnowledge(query, { limit: 5 });\n          \n          console.log(`\\n🔍 Search Results for \"${query}\":`);\n          results.forEach((result, index) => {\n            console.log(`\\n${index + 1}. Relevance: ${(result.relevance * 100).toFixed(1)}%`);\n            console.log(`Source: ${result.metadata.fileName || 'Text'}`);\n            console.log(`Content: ${result.content.substring(0, 200)}...`);\n          });\n          console.log('');\n        } else {\n          console.log('❌ Please provide a search query: /search <query>');\n        }\n        break;\n        \n      case '/stats':\n        const stats = await this.agent.getKnowledgeStats();\n        console.log('\\n📊 Knowledge Base Statistics:');\n        console.log(`Total Documents: ${stats.totalDocuments}`);\n        console.log('Categories:', Object.keys(stats.categories).length);\n        console.log('File Types:', Object.keys(stats.fileTypes).length);\n        console.log('');\n        break;\n        \n      case '/export':\n        const exportText = await this.agent.exportConversation();\n        console.log('\\n' + exportText);\n        break;\n        \n      case '/help':\n        console.log(`\n🔧 Available Commands:\n- /ingest <file> [category] - Ingest a document\n- /ingest-text [category] - Ingest text manually\n- /search <query> - Search knowledge base\n- /stats - Show knowledge base statistics\n- /export - Export current conversation\n- /help - Show this help\n- /quit - Exit the agent\n`);\n        break;\n        \n      default:\n        console.log('❌ Unknown command. Type /help for available commands.');\n    }\n  }\n  \n  private collectText(callback: (text: string) => void): void {\n    let text = '';\n    const collectLine = () => {\n      this.readline.question('', (line: string) => {\n        if (line.trim() === 'END') {\n          callback(text);\n          this.askQuestion();\n        } else {\n          text += line + '\\n';\n          collectLine();\n        }\n      });\n    };\n    collectLine();\n  }\n}\n\n// Document ingestion utilities\nclass DocumentProcessor {\n  static async ingestDirectory(agent: KnowledgeBaseAgent, dirPath: string, options?: {\n    recursive?: boolean;\n    fileTypes?: string[];\n    category?: string;\n  }): Promise<void> {\n    const files = fs.readdirSync(dirPath);\n    const allowedTypes = options?.fileTypes || ['.txt', '.md', '.json'];\n    \n    for (const file of files) {\n      const filePath = path.join(dirPath, file);\n      const stat = fs.statSync(filePath);\n      \n      if (stat.isDirectory() && options?.recursive) {\n        await this.ingestDirectory(agent, filePath, options);\n      } else if (stat.isFile()) {\n        const ext = path.extname(file);\n        if (allowedTypes.includes(ext)) {\n          try {\n            await agent.ingestDocument(filePath, {\n              category: options?.category || 'auto_ingested',\n              directory: dirPath\n            });\n          } catch (error) {\n            console.error(`Failed to ingest ${filePath}:`, error);\n          }\n        }\n      }\n    }\n  }\n  \n  static async ingestWebContent(agent: KnowledgeBaseAgent, url: string, metadata?: Record<string, any>): Promise<void> {\n    // This would require a web scraping library like puppeteer or cheerio\n    // For now, we'll show the structure\n    console.log(`Would ingest content from ${url}`);\n    \n    // Example implementation:\n    // const content = await scrapeWebContent(url);\n    // await agent.ingestText(content, {\n    //   source: 'web',\n    //   url,\n    //   scrapedAt: new Date().toISOString(),\n    //   ...metadata\n    // });\n  }\n}\n\n// Usage examples\nasync function main() {\n  const userId = process.argv[2] || 'default_user';\n  const knowledgeBaseName = process.argv[3] || 'main_kb';\n  \n  const cli = new KnowledgeBaseCLI(userId, knowledgeBaseName);\n  await cli.start();\n}\n\n// Example of programmatic usage\nasync function exampleUsage() {\n  const agent = new KnowledgeBaseAgent('example_user', 'tech_kb');\n  \n  // Ingest some documents\n  await agent.ingestText(`\n    TypeScript is a programming language developed by Microsoft.\n    It is a strict syntactical superset of JavaScript and adds \n    optional static type checking to the language.\n  `, {\n    category: 'programming',\n    topic: 'typescript',\n    source: 'manual'\n  });\n  \n  await agent.ingestText(`\n    React is a JavaScript library for building user interfaces.\n    It was developed by Facebook and is maintained by Facebook \n    and the community.\n  `, {\n    category: 'programming',\n    topic: 'react',\n    source: 'manual'\n  });\n  \n  // Start conversation and ask questions\n  await agent.startConversation('programming');\n  \n  const result1 = await agent.query('What is TypeScript?');\n  console.log('Answer:', result1.answer);\n  console.log('Confidence:', result1.confidence);\n  \n  const result2 = await agent.query('How does React relate to TypeScript?');\n  console.log('Answer:', result2.answer);\n  \n  agent.close();\n}\n\n// Run the CLI or example\nif (require.main === module) {\n  if (process.argv.includes('--example')) {\n    exampleUsage().catch(console.error);\n  } else {\n    main().catch(console.error);\n  }\n}\n```\n\n## Step-by-Step Breakdown\n\n### Step 1: Initialize Knowledge Components\n\n```typescript\nclass KnowledgeBaseAgent {\n  private hero: Hero;\n  private room: Room;\n  private codex: Codex;\n  \n  constructor(userId: string, knowledgeBaseName: string = 'default_kb') {\n    // Hero with RAG-optimized settings\n    this.hero = new Hero({\n      model: 'gpt-3.5-turbo',\n      temperature: 0.3, // Lower for factual responses\n      systemPrompt: `You are a knowledgeable AI assistant...`\n    });\n    \n    // Room for conversation memory\n    this.room = Room.create({\n      name: `${userId}_kb_conversations`\n    });\n    \n    // Codex for knowledge storage\n    this.codex = Codex.create({\n      tableName: `kb_${knowledgeBaseName}`,\n      model: 'text-embedding-ada-002'\n    });\n  }\n}\n```\n\n**Key Points:**\n- Lower temperature for more factual responses\n- Separate knowledge base per domain/user\n- Room maintains conversation context\n- Codex provides semantic search capabilities\n\n### Step 2: Document Ingestion\n\n```typescript\nasync ingestDocument(filePath: string, metadata?: Record<string, any>): Promise<void> {\n  const content = fs.readFileSync(filePath, 'utf-8');\n  const fileName = path.basename(filePath);\n  \n  // Split document into chunks\n  const chunks = this.chunkDocument(content, 500);\n  \n  for (let i = 0; i < chunks.length; i++) {\n    const chunkMetadata = {\n      fileName,\n      chunkIndex: i,\n      totalChunks: chunks.length,\n      filePath,\n      ingestedAt: new Date().toISOString(),\n      ...metadata\n    };\n    \n    await this.codex.add(chunks[i], chunkMetadata);\n  }\n}\n\nprivate chunkDocument(content: string, maxChunkSize: number): string[] {\n  // Split by paragraphs first\n  const paragraphs = content.split(/\\n\\s*\\n/).filter(p => p.trim().length > 0);\n  const chunks: string[] = [];\n  let currentChunk = '';\n  \n  for (const paragraph of paragraphs) {\n    if (currentChunk.length + paragraph.length > maxChunkSize) {\n      if (currentChunk.trim()) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n      }\n    }\n    currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph;\n  }\n  \n  if (currentChunk.trim()) {\n    chunks.push(currentChunk.trim());\n  }\n  \n  return chunks;\n}\n```\n\n**Key Points:**\n- Documents are split into manageable chunks\n- Rich metadata enables better filtering\n- Chunk boundaries respect paragraph structure\n- Each chunk is independently searchable\n\n### Step 3: Knowledge-Enhanced Querying\n\n```typescript\nasync query(userQuestion: string): Promise<{\n  answer: string;\n  sources: Array<{...}>;\n  confidence: 'high' | 'medium' | 'low';\n}> {\n  // Search knowledge base\n  const knowledgeResults = await this.codex.search(userQuestion, {\n    limit: 5,\n    distanceThreshold: 0.4\n  });\n  \n  // Build context from search results\n  const context = knowledgeResults\n    .map((result, index) => `[Source ${index + 1}]: ${result.content}`)\n    .join('\\n\\n');\n  \n  // Enhanced prompt with knowledge context\n  const enhancedPrompt = `Context from knowledge base:\n${context}\n\nUser question: ${userQuestion}\n\nPlease answer using the provided context.`;\n  \n  const response = await this.hero.query(enhancedPrompt);\n  \n  // Determine confidence based on search results\n  let confidence: 'high' | 'medium' | 'low' = 'low';\n  if (knowledgeResults.length > 0) {\n    const avgDistance = knowledgeResults.reduce((sum, r) => sum + r.distance, 0) / knowledgeResults.length;\n    if (avgDistance < 0.2) confidence = 'high';\n    else if (avgDistance < 0.4) confidence = 'medium';\n  }\n  \n  return { answer: response, sources: knowledgeResults, confidence };\n}\n```\n\n**Key Points:**\n- Semantic search finds relevant knowledge chunks\n- Context is injected into the AI prompt\n- Confidence scoring based on search relevance\n- Source attribution for transparency\n\n## Running the Example\n\n### 1. Setup Project\n\n```bash\nmkdir knowledge-base-agent\ncd knowledge-base-agent\n\nnpm init -y\nnpm install downcity\nnpm install -D typescript @types/node\n\ntouch knowledge-agent.ts\n```\n\n### 2. Prepare Knowledge Documents\n\nCreate some sample documents:\n\n```bash\nmkdir docs\necho \"TypeScript is a strongly typed programming language that builds on JavaScript.\" > docs/typescript.txt\necho \"React is a JavaScript library for building user interfaces.\" > docs/react.txt\necho \"Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine.\" > docs/nodejs.txt\n```\n\n### 3. Run the Agent\n\n```bash\n# Run with CLI interface\nnpx ts-node knowledge-agent.ts my_user tech_knowledge\n\n# Run example usage\nnpx ts-node knowledge-agent.ts --example\n```\n\n### 4. Example Interaction\n\n```\n📚 Knowledge Base Agent Started!\nCommands: /ingest <file>, /ingest-text, /search <query>, /stats, /export, /help, /quit\n\n🧠 Started knowledge-based conversation about knowledge_query\n\nYou: /ingest docs/typescript.txt programming\n📄 Ingesting document: typescript.txt\n✅ Successfully ingested 1 chunks from typescript.txt\n\nYou: /ingest docs/react.txt programming\n📄 Ingesting document: react.txt\n✅ Successfully ingested 1 chunks from react.txt\n\nYou: What is TypeScript?\n🤖 Searching knowledge base...\n🔍 Found 1 relevant knowledge chunks\n\nAgent: Based on my knowledge base, TypeScript is a strongly typed programming language that builds on JavaScript. It provides static type checking which helps catch errors during development and makes code more maintainable and robust.\n\n📊 Confidence: HIGH\n\n📚 Sources used (1):\n1. typescript.txt (relevance: 95.2%)\n\nYou: How does TypeScript compare to React?\n🤖 Searching knowledge base...\n🔍 Found 2 relevant knowledge chunks\n\nAgent: TypeScript and React serve different purposes but work well together. TypeScript is a strongly typed programming language that builds on JavaScript, providing static type checking for better code quality. React, on the other hand, is a JavaScript library specifically for building user interfaces. You can use TypeScript with React to get the benefits of type safety in your React applications.\n\n📊 Confidence: HIGH\n\n📚 Sources used (2):\n1. typescript.txt (relevance: 87.3%)\n2. react.txt (relevance: 82.1%)\n\nYou: /search \"user interfaces\"\n\n🔍 Search Results for \"user interfaces\":\n\n1. Relevance: 89.4%\nSource: react.txt\nContent: React is a JavaScript library for building user interfaces...\n```\n\n## Advanced Features\n\n### Multi-Domain Knowledge Management\n\n```typescript\nclass MultiDomainKnowledgeAgent {\n  private agents: Map<string, KnowledgeBaseAgent> = new Map();\n  private currentDomain: string = 'general';\n  \n  constructor(private userId: string) {}\n  \n  async createDomain(domain: string): Promise<void> {\n    if (!this.agents.has(domain)) {\n      const agent = new KnowledgeBaseAgent(this.userId, domain);\n      this.agents.set(domain, agent);\n      console.log(`📚 Created knowledge domain: ${domain}`);\n    }\n  }\n  \n  async switchDomain(domain: string): Promise<boolean> {\n    if (this.agents.has(domain)) {\n      this.currentDomain = domain;\n      console.log(`🔄 Switched to domain: ${domain}`);\n      return true;\n    }\n    return false;\n  }\n  \n  async queryAcrossDomains(question: string): Promise<{\n    results: Array<{\n      domain: string;\n      answer: string;\n      confidence: string;\n      sources: number;\n    }>;\n    bestAnswer: string;\n  }> {\n    const results = [];\n    \n    for (const [domain, agent] of this.agents) {\n      try {\n        const result = await agent.query(question);\n        results.push({\n          domain,\n          answer: result.answer,\n          confidence: result.confidence,\n          sources: result.sources.length\n        });\n      } catch (error) {\n        console.error(`Error querying domain ${domain}:`, error);\n      }\n    }\n    \n    // Find best answer based on confidence and source count\n    const bestResult = results.reduce((best, current) => {\n      const currentScore = this.scoreResult(current);\n      const bestScore = this.scoreResult(best);\n      return currentScore > bestScore ? current : best;\n    });\n    \n    return {\n      results,\n      bestAnswer: bestResult?.answer || \"No suitable answer found.\"\n    };\n  }\n  \n  private scoreResult(result: { confidence: string; sources: number }): number {\n    const confidenceScore = {\n      'high': 3,\n      'medium': 2,\n      'low': 1\n    }[result.confidence] || 0;\n    \n    return confidenceScore + (result.sources * 0.5);\n  }\n}\n```\n\n### Knowledge Quality Assessment\n\n```typescript\nclass KnowledgeQualityAssessor {\n  static assessChunkQuality(content: string, metadata: Record<string, any>): {\n    score: number;\n    issues: string[];\n    recommendations: string[];\n  } {\n    const issues = [];\n    const recommendations = [];\n    let score = 0.5; // Base score\n    \n    // Content length assessment\n    if (content.length < 50) {\n      issues.push('Content too short');\n      recommendations.push('Combine with related content');\n    } else if (content.length > 1000) {\n      issues.push('Content too long');\n      recommendations.push('Split into smaller chunks');\n      score -= 0.1;\n    } else {\n      score += 0.2;\n    }\n    \n    // Metadata completeness\n    const requiredFields = ['category', 'source'];\n    const missingFields = requiredFields.filter(field => !metadata[field]);\n    \n    if (missingFields.length === 0) {\n      score += 0.2;\n    } else {\n      issues.push(`Missing metadata: ${missingFields.join(', ')}`);\n      recommendations.push('Add missing metadata fields');\n      score -= 0.1 * missingFields.length;\n    }\n    \n    // Content structure assessment\n    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    if (sentences.length > 1) {\n      score += 0.1;\n    }\n    \n    // Source attribution\n    if (metadata.source && metadata.source !== 'unknown') {\n      score += 0.1;\n    } else {\n      recommendations.push('Add source attribution');\n    }\n    \n    return {\n      score: Math.max(0, Math.min(1, score)),\n      issues,\n      recommendations\n    };\n  }\n  \n  static async assessKnowledgeBase(agent: KnowledgeBaseAgent): Promise<{\n    overallScore: number;\n    totalChunks: number;\n    qualityDistribution: Record<string, number>;\n    recommendations: string[];\n  }> {\n    // This would require additional methods to access all chunks\n    // For demonstration purposes\n    return {\n      overallScore: 0.75,\n      totalChunks: 100,\n      qualityDistribution: {\n        'high': 60,\n        'medium': 30,\n        'low': 10\n      },\n      recommendations: [\n        'Improve metadata for low-quality chunks',\n        'Add more diverse sources',\n        'Regular quality audits'\n      ]\n    };\n  }\n}\n```\n\n### Automated Knowledge Updates\n\n```typescript\nclass KnowledgeUpdater {\n  constructor(private agent: KnowledgeBaseAgent) {}\n  \n  async scheduleUpdate(source: {\n    type: 'file' | 'directory' | 'url';\n    path: string;\n    interval: number; // milliseconds\n    metadata?: Record<string, any>;\n  }): Promise<void> {\n    setInterval(async () => {\n      try {\n        console.log(`🔄 Updating knowledge from ${source.path}`);\n        \n        switch (source.type) {\n          case 'file':\n            await this.agent.ingestDocument(source.path, {\n              ...source.metadata,\n              lastUpdated: new Date().toISOString(),\n              updateType: 'scheduled'\n            });\n            break;\n            \n          case 'directory':\n            await DocumentProcessor.ingestDirectory(\n              this.agent,\n              source.path,\n              { category: source.metadata?.category }\n            );\n            break;\n            \n          case 'url':\n            await DocumentProcessor.ingestWebContent(\n              this.agent,\n              source.path,\n              source.metadata\n            );\n            break;\n        }\n        \n        console.log(`✅ Knowledge update completed for ${source.path}`);\n      } catch (error) {\n        console.error(`❌ Knowledge update failed for ${source.path}:`, error);\n      }\n    }, source.interval);\n  }\n  \n  async detectChanges(filePath: string): Promise<boolean> {\n    // Implementation would check file modification time\n    // against last ingestion time\n    return false;\n  }\n}\n```\n\n## Testing Knowledge Base\n\n### Unit Tests\n\n```typescript\n// knowledge-agent.test.ts\nimport { KnowledgeBaseAgent } from './knowledge-agent';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ndescribe('KnowledgeBaseAgent', () => {\n  let agent: KnowledgeBaseAgent;\n  const testDir = './test-docs';\n  \n  beforeEach(async () => {\n    agent = new KnowledgeBaseAgent('test_user', 'test_kb');\n    \n    // Create test documents\n    if (!fs.existsSync(testDir)) {\n      fs.mkdirSync(testDir);\n    }\n    \n    fs.writeFileSync(\n      path.join(testDir, 'test-doc.txt'),\n      'This is a test document about artificial intelligence and machine learning.'\n    );\n  });\n  \n  afterEach(() => {\n    agent.close();\n    \n    // Cleanup test files\n    if (fs.existsSync(testDir)) {\n      fs.rmSync(testDir, { recursive: true });\n    }\n  });\n  \n  test('should ingest and retrieve document content', async () => {\n    await agent.ingestDocument(\n      path.join(testDir, 'test-doc.txt'),\n      { category: 'test' }\n    );\n    \n    const result = await agent.query('What is artificial intelligence?');\n    \n    expect(result.answer).toBeTruthy();\n    expect(result.sources.length).toBeGreaterThan(0);\n    expect(result.confidence).toBe('high');\n  });\n  \n  test('should handle queries with no relevant knowledge', async () => {\n    const result = await agent.query('What is quantum computing?');\n    \n    expect(result.answer).toBeTruthy();\n    expect(result.sources.length).toBe(0);\n    expect(result.confidence).toBe('low');\n  });\n  \n  test('should chunk documents appropriately', async () => {\n    const longContent = 'A'.repeat(2000); // Very long content\n    \n    await agent.ingestText(longContent, { category: 'test' });\n    \n    const results = await agent.searchKnowledge('A', { limit: 10 });\n    expect(results.length).toBeGreaterThan(1); // Should be chunked\n  });\n});\n```\n\n### Integration Tests\n\n```typescript\ndescribe('Knowledge Base Integration', () => {\n  test('should maintain knowledge across agent restarts', async () => {\n    const kbName = 'persistence_test';\n    \n    // First agent instance\n    const agent1 = new KnowledgeBaseAgent('test_user', kbName);\n    await agent1.ingestText('React is a JavaScript library', { category: 'tech' });\n    agent1.close();\n    \n    // Second agent instance\n    const agent2 = new KnowledgeBaseAgent('test_user', kbName);\n    const result = await agent2.query('What is React?');\n    \n    expect(result.sources.length).toBeGreaterThan(0);\n    expect(result.answer.toLowerCase()).toContain('javascript');\n    \n    agent2.close();\n  });\n});\n```\n\n## Best Practices\n\n### Knowledge Organization\n\n1. **Consistent Metadata**: Use standardized metadata schemas\n2. **Logical Chunking**: Respect document structure when chunking\n3. **Source Attribution**: Always track content sources\n4. **Category Hierarchy**: Use hierarchical categorization\n\n### Performance Optimization\n\n1. **Chunk Size**: Balance between context and search precision\n2. **Search Limits**: Use appropriate result limits\n3. **Caching**: Cache frequent queries\n4. **Batch Processing**: Ingest documents in batches\n\n### Quality Control\n\n1. **Content Validation**: Validate content before ingestion\n2. **Duplicate Detection**: Avoid ingesting duplicate content\n3. **Regular Audits**: Periodically review knowledge quality\n4. **User Feedback**: Collect feedback on answer quality\n\n## Next Steps\n\nAfter mastering knowledge base integration:\n\n1. **[Advanced Patterns](/docs/guides/advanced-patterns)** - Complex agent architectures\n2. **[Memory Management](/docs/guides/memory-management)** - Optimizing memory usage\n3. **[Building Chatbot](/docs/guides/building-chatbot)** - Production chatbot patterns\n\n## Related Documentation\n\n- [Codex API Reference](/docs/api-reference/codex-api) - Detailed Codex methods\n- [Knowledge Integration Guide](/docs/guides/knowledge-integration) - Advanced knowledge patterns\n- [Memory System](/docs/core-concepts/memory-system) - Understanding the memory hierarchy